--- origsrc/gettext-0.18.1.1/gettext-runtime/gnulib-lib/progreloc.c	2010-02-16 15:31:28.000000000 -0600
+++ src/gettext-0.18.1.1/gettext-runtime/gnulib-lib/progreloc.c	2011-10-31 18:40:26.619853680 -0500
@@ -16,6 +16,7 @@
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 
+#define _GL_USE_STDLIB_ALLOC 1
 #include <config.h>
 
 /* Specification.  */
@@ -34,11 +35,11 @@
 # include <mach-o/dyld.h>
 #endif
 
-#if defined _WIN32 || defined __WIN32__
+#if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__
 # define WIN32_NATIVE
 #endif
 
-#if defined WIN32_NATIVE || defined __CYGWIN__
+#ifdef WIN32_NATIVE
 # define WIN32_LEAN_AND_MEAN
 # include <windows.h>
 #endif
@@ -59,6 +60,10 @@
 # include "xalloc.h"
 #endif
 
+#ifndef O_EXEC
+# define O_EXEC O_RDONLY /* This is often close enough in older systems.  */
+#endif
+
 /* Declare canonicalize_file_name.
    The <stdlib.h> included above may be the system's one, not the gnulib
    one.  */
@@ -68,8 +73,8 @@ extern char * canonicalize_file_name (co
    ISSLASH(C)           tests whether C is a directory separator character.
    IS_PATH_WITH_DIR(P)  tests whether P contains a directory specification.
  */
-#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__
-  /* Win32, Cygwin, OS/2, DOS */
+#if ((defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__) || defined __EMX__ || defined __DJGPP__
+  /* Win32, OS/2, DOS */
 # define ISSLASH(C) ((C) == '/' || (C) == '\\')
 # define HAS_DEVICE(P) \
     ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \
@@ -89,12 +94,15 @@ extern char * canonicalize_file_name (co
 #undef open
 #undef close
 
+/* Use the system functions, not the gnulib overrides in this file.  */
+#undef sprintf
+
 #undef set_program_name
 
 
 #if ENABLE_RELOCATABLE
 
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 /* File descriptor of the executable.
    (Only used to verify that we find the correct executable.)  */
 static int executable_fd = -1;
@@ -104,12 +112,13 @@ static int executable_fd = -1;
 static bool
 maybe_executable (const char *filename)
 {
-  /* Woe32 lacks the access() function, but Cygwin doesn't.  */
-#if !(defined WIN32_NATIVE && !defined __CYGWIN__)
+  /* Woe32 lacks the access() function.  */
+#if !defined WIN32_NATIVE
   if (access (filename, X_OK) < 0)
     return false;
+#endif
 
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
   if (executable_fd >= 0)
     {
       /* If we already have an executable_fd, check that filename points to
@@ -128,7 +137,6 @@ maybe_executable (const char *filename)
         }
     }
 #endif
-#endif
 
   return true;
 }
@@ -140,7 +148,12 @@ maybe_executable (const char *filename)
 static char *
 find_executable (const char *argv0)
 {
-#if defined WIN32_NATIVE || defined __CYGWIN__
+#if defined WIN32_NATIVE
+  /* Native Win32 only.
+     On Cygwin, it is better to use the Cygwin provided /proc interface, than
+     to use native Win32 API and cygwin_conv_to_posix_path, because it supports
+     longer file names
+     (see <http://cygwin.com/ml/cygwin/2011-01/msg00410.html>).  */
   char location[MAX_PATH];
   int length = GetModuleFileName (NULL, location, sizeof (location));
   if (length < 0)
@@ -148,32 +161,9 @@ find_executable (const char *argv0)
   if (!IS_PATH_WITH_DIR (location))
     /* Shouldn't happen.  */
     return NULL;
-  {
-#if defined __CYGWIN__
-    /* cygwin-1.5.13 (2005-03-01) or newer would also allow a Linux-like
-       implementation: readlink of "/proc/self/exe".  But using the
-       result of the Win32 system call is simpler and is consistent with the
-       code in relocatable.c.  */
-    /* On Cygwin, we need to convert paths coming from Win32 system calls
-       to the Unix-like slashified notation.  */
-    static char location_as_posix_path[2 * MAX_PATH];
-    /* There's no error return defined for cygwin_conv_to_posix_path.
-       See cygwin-api/func-cygwin-conv-to-posix-path.html.
-       Does it overflow the buffer of expected size MAX_PATH or does it
-       truncate the path?  I don't know.  Let's catch both.  */
-    cygwin_conv_to_posix_path (location, location_as_posix_path);
-    location_as_posix_path[MAX_PATH - 1] = '\0';
-    if (strlen (location_as_posix_path) >= MAX_PATH - 1)
-      /* A sign of buffer overflow or path truncation.  */
-      return NULL;
-    /* Call canonicalize_file_name, because Cygwin supports symbolic links.  */
-    return canonicalize_file_name (location_as_posix_path);
-#else
-    return xstrdup (location);
-#endif
-  }
-#else /* Unix && !Cygwin */
-#ifdef __linux__
+  return xstrdup (location);
+#else /* Unix */
+# ifdef __linux__
   /* The executable is accessible as /proc/<pid>/exe.  In newer Linux
      versions, also as /proc/self/exe.  Linux >= 2.1 provides a symlink
      to the true pathname; older Linux versions give only device and ino,
@@ -185,7 +175,7 @@ find_executable (const char *argv0)
     if (link != NULL && link[0] != '[')
       return link;
     if (executable_fd < 0)
-      executable_fd = open ("/proc/self/exe", O_RDONLY, 0);
+      executable_fd = open ("/proc/self/exe", O_EXEC, 0);
 
     {
       char buf[6+10+5];
@@ -194,11 +184,24 @@ find_executable (const char *argv0)
       if (link != NULL && link[0] != '[')
         return link;
       if (executable_fd < 0)
-        executable_fd = open (buf, O_RDONLY, 0);
+        executable_fd = open (buf, O_EXEC, 0);
     }
   }
-#endif
-#if HAVE_MACH_O_DYLD_H && HAVE__NSGETEXECUTABLEPATH
+# endif
+# ifdef __CYGWIN__
+  /* The executable is accessible as /proc/<pid>/exe, at least in
+     Cygwin >= 1.5.  */
+  {
+    char *link;
+
+    link = xreadlink ("/proc/self/exe");
+    if (link != NULL)
+      return link;
+    if (executable_fd < 0)
+      executable_fd = open ("/proc/self/exe", O_EXEC, 0);
+  }
+# endif
+# if HAVE_MACH_O_DYLD_H && HAVE__NSGETEXECUTABLEPATH
   /* On MacOS X 10.2 or newer, the function
        int _NSGetExecutablePath (char *buf, uint32_t *bufsize);
      can be used to retrieve the executable's full path.  */
@@ -207,7 +210,7 @@ find_executable (const char *argv0)
   if (_NSGetExecutablePath (location, &length) == 0
       && location[0] == '/')
     return canonicalize_file_name (location);
-#endif
+# endif
   /* Guess the executable's full path.  We assume the executable has been
      called via execlp() or execvp() with properly set up argv[0].  The
      login(1) convention to add a '-' prefix to argv[0] is not supported.  */
@@ -248,10 +251,10 @@ find_executable (const char *argv0)
                 /* We have a path item at p, of length p_len.
                    Now concatenate the path item and argv0.  */
                 concat_name = (char *) xmalloc (p_len + strlen (argv0) + 2);
-#ifdef NO_XMALLOC
+# ifdef NO_XMALLOC
                 if (concat_name == NULL)
                   return NULL;
-#endif
+# endif
                 if (p_len == 0)
                   /* An empty PATH element designates the current directory.  */
                   strcpy (concat_name, argv0);
--- origsrc/gettext-0.18.1.1/gettext-runtime/gnulib-lib/relocatable.c	2010-02-16 15:31:28.000000000 -0600
+++ src/gettext-0.18.1.1/gettext-runtime/gnulib-lib/relocatable.c	2011-10-31 18:40:29.867853399 -0500
@@ -25,6 +23,7 @@
 # define _GNU_SOURCE 1
 #endif
 
+#define _GL_USE_STDLIB_ALLOC 1
 #include <config.h>
 
 /* Specification.  */
@@ -43,7 +42,7 @@
 # include "xalloc.h"
 #endif
 
-#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__
+#if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__
 # define WIN32_LEAN_AND_MEAN
 # include <windows.h>
 #endif
@@ -70,8 +69,8 @@
    ISSLASH(C)           tests whether C is a directory separator character.
    IS_PATH_WITH_DIR(P)  tests whether P contains a directory specification.
  */
-#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__
-  /* Win32, Cygwin, OS/2, DOS */
+#if ((defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__) || defined __EMX__ || defined __DJGPP__
+  /* Win32, OS/2, DOS */
 # define ISSLASH(C) ((C) == '/' || (C) == '\\')
 # define HAS_DEVICE(P) \
     ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \
@@ -86,6 +85,19 @@
 # define FILE_SYSTEM_PREFIX_LEN(P) 0
 #endif
 
+/* Whether to enable the more costly support for relocatable libraries.
+   It allows libraries to be have been installed with a different original
+   prefix than the program.  But it is quite costly, especially on Cygwin
+   platforms, see below.  Therefore we enable it by default only on native
+   Win32 platforms.  */
+#ifndef ENABLE_COSTLY_RELOCATABLE
+# if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__
+#  define ENABLE_COSTLY_RELOCATABLE 1
+# else
+#  define ENABLE_COSTLY_RELOCATABLE 0
+# endif
+#endif
+
 /* Original installation prefix.  */
 static char *orig_prefix;
 static size_t orig_prefix_len;
@@ -155,7 +167,7 @@ set_relocation_prefix (const char *orig_
 #endif
 }
 
-#if !defined IN_LIBRARY || (defined PIC && defined INSTALLDIR)
+#if !defined IN_LIBRARY || (defined PIC && defined INSTALLDIR && ENABLE_COSTLY_RELOCATABLE)
 
 /* Convenience function:
    Computes the current installation prefix, based on the original
@@ -285,12 +297,17 @@ compute_curr_prefix (const char *orig_in
 
 #endif /* !IN_LIBRARY || PIC */
 
-#if defined PIC && defined INSTALLDIR
+#if defined PIC && defined INSTALLDIR && ENABLE_COSTLY_RELOCATABLE
 
 /* Full pathname of shared library, or NULL.  */
 static char *shared_library_fullname;
 
-#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__
+#if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__
+/* Native Win32 only.
+   On Cygwin, it is better to use the Cygwin provided /proc interface, than
+   to use native Win32 API and cygwin_conv_to_posix_path, because it supports
+   longer file names
+   (see <http://cygwin.com/ml/cygwin/2011-01/msg00410.html>).  */
 
 /* Determine the full pathname of the shared library when it is loaded.  */
 
@@ -312,37 +329,23 @@ DllMain (HINSTANCE module_handle, DWORD 
         /* Shouldn't happen.  */
         return FALSE;
 
-      {
-#if defined __CYGWIN__
-        /* On Cygwin, we need to convert paths coming from Win32 system calls
-           to the Unix-like slashified notation.  */
-        static char location_as_posix_path[2 * MAX_PATH];
-        /* There's no error return defined for cygwin_conv_to_posix_path.
-           See cygwin-api/func-cygwin-conv-to-posix-path.html.
-           Does it overflow the buffer of expected size MAX_PATH or does it
-           truncate the path?  I don't know.  Let's catch both.  */
-        cygwin_conv_to_posix_path (location, location_as_posix_path);
-        location_as_posix_path[MAX_PATH - 1] = '\0';
-        if (strlen (location_as_posix_path) >= MAX_PATH - 1)
-          /* A sign of buffer overflow or path truncation.  */
-          return FALSE;
-        shared_library_fullname = strdup (location_as_posix_path);
-#else
-        shared_library_fullname = strdup (location);
-#endif
-      }
+      shared_library_fullname = strdup (location);
     }
 
   return TRUE;
 }
 
-#else /* Unix except Cygwin */
+#else /* Unix */
 
 static void
 find_shared_library_fullname ()
 {
-#if defined __linux__ && __GLIBC__ >= 2
-  /* Linux has /proc/self/maps. glibc 2 has the getline() function.  */
+#if (defined __linux__ && (__GLIBC__ >= 2 || defined __UCLIBC__)) || defined __CYGWIN__
+  /* Linux has /proc/self/maps. glibc 2 and uClibc have the getline()
+     function.
+     Cygwin >= 1.5 has /proc/self/maps and the getline() function too.
+     But it is costly: ca. 0.3 ms on Linux, 3 ms on Cygwin 1.5, and 5 ms on
+     Cygwin 1.7.  */
   FILE *fp;
 
   /* Open the current process' maps file.  It describes one VMA per line.  */
@@ -387,7 +390,7 @@ find_shared_library_fullname ()
 #endif
 }
 
-#endif /* (WIN32 or Cygwin) / (Unix except Cygwin) */
+#endif /* WIN32 / Unix */
 
 /* Return the full pathname of the current shared library.
    Return NULL if unknown.
@@ -395,7 +398,7 @@ find_shared_library_fullname ()
 static char *
 get_shared_library_fullname ()
 {
-#if !(defined _WIN32 || defined __WIN32__ || defined __CYGWIN__)
+#if !((defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__)
   static bool tried_find_shared_library_fullname;
   if (!tried_find_shared_library_fullname)
     {
@@ -415,7 +418,7 @@ get_shared_library_fullname ()
 const char *
 relocate (const char *pathname)
 {
-#if defined PIC && defined INSTALLDIR
+#if defined PIC && defined INSTALLDIR && ENABLE_COSTLY_RELOCATABLE
   static int initialized;
 
   /* Initialization code for a shared library.  */
--- origsrc/gettext-0.18.1.1/gettext-runtime/intl/relocatable.c	2010-06-06 07:49:57.000000000 -0500
+++ src/gettext-0.18.1.1/gettext-runtime/intl/relocatable.c	2011-10-31 18:40:29.867853399 -0500
@@ -25,6 +23,7 @@
 # define _GNU_SOURCE 1
 #endif
 
+#define _GL_USE_STDLIB_ALLOC 1
 #include <config.h>
 
 /* Specification.  */
@@ -43,7 +42,7 @@
 # include "xalloc.h"
 #endif
 
-#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__
+#if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__
 # define WIN32_LEAN_AND_MEAN
 # include <windows.h>
 #endif
@@ -70,8 +69,8 @@
    ISSLASH(C)           tests whether C is a directory separator character.
    IS_PATH_WITH_DIR(P)  tests whether P contains a directory specification.
  */
-#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__
-  /* Win32, Cygwin, OS/2, DOS */
+#if ((defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__) || defined __EMX__ || defined __DJGPP__
+  /* Win32, OS/2, DOS */
 # define ISSLASH(C) ((C) == '/' || (C) == '\\')
 # define HAS_DEVICE(P) \
     ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \
@@ -86,6 +85,19 @@
 # define FILE_SYSTEM_PREFIX_LEN(P) 0
 #endif
 
+/* Whether to enable the more costly support for relocatable libraries.
+   It allows libraries to be have been installed with a different original
+   prefix than the program.  But it is quite costly, especially on Cygwin
+   platforms, see below.  Therefore we enable it by default only on native
+   Win32 platforms.  */
+#ifndef ENABLE_COSTLY_RELOCATABLE
+# if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__
+#  define ENABLE_COSTLY_RELOCATABLE 1
+# else
+#  define ENABLE_COSTLY_RELOCATABLE 0
+# endif
+#endif
+
 /* Original installation prefix.  */
 static char *orig_prefix;
 static size_t orig_prefix_len;
@@ -155,7 +167,7 @@ set_relocation_prefix (const char *orig_
 #endif
 }
 
-#if !defined IN_LIBRARY || (defined PIC && defined INSTALLDIR)
+#if !defined IN_LIBRARY || (defined PIC && defined INSTALLDIR && ENABLE_COSTLY_RELOCATABLE)
 
 /* Convenience function:
    Computes the current installation prefix, based on the original
@@ -285,12 +297,17 @@ compute_curr_prefix (const char *orig_in
 
 #endif /* !IN_LIBRARY || PIC */
 
-#if defined PIC && defined INSTALLDIR
+#if defined PIC && defined INSTALLDIR && ENABLE_COSTLY_RELOCATABLE
 
 /* Full pathname of shared library, or NULL.  */
 static char *shared_library_fullname;
 
-#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__
+#if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__
+/* Native Win32 only.
+   On Cygwin, it is better to use the Cygwin provided /proc interface, than
+   to use native Win32 API and cygwin_conv_to_posix_path, because it supports
+   longer file names
+   (see <http://cygwin.com/ml/cygwin/2011-01/msg00410.html>).  */
 
 /* Determine the full pathname of the shared library when it is loaded.  */
 
@@ -312,37 +329,23 @@ DllMain (HINSTANCE module_handle, DWORD 
         /* Shouldn't happen.  */
         return FALSE;
 
-      {
-#if defined __CYGWIN__
-        /* On Cygwin, we need to convert paths coming from Win32 system calls
-           to the Unix-like slashified notation.  */
-        static char location_as_posix_path[2 * MAX_PATH];
-        /* There's no error return defined for cygwin_conv_to_posix_path.
-           See cygwin-api/func-cygwin-conv-to-posix-path.html.
-           Does it overflow the buffer of expected size MAX_PATH or does it
-           truncate the path?  I don't know.  Let's catch both.  */
-        cygwin_conv_to_posix_path (location, location_as_posix_path);
-        location_as_posix_path[MAX_PATH - 1] = '\0';
-        if (strlen (location_as_posix_path) >= MAX_PATH - 1)
-          /* A sign of buffer overflow or path truncation.  */
-          return FALSE;
-        shared_library_fullname = strdup (location_as_posix_path);
-#else
-        shared_library_fullname = strdup (location);
-#endif
-      }
+      shared_library_fullname = strdup (location);
     }
 
   return TRUE;
 }
 
-#else /* Unix except Cygwin */
+#else /* Unix */
 
 static void
 find_shared_library_fullname ()
 {
-#if defined __linux__ && __GLIBC__ >= 2
-  /* Linux has /proc/self/maps. glibc 2 has the getline() function.  */
+#if (defined __linux__ && (__GLIBC__ >= 2 || defined __UCLIBC__)) || defined __CYGWIN__
+  /* Linux has /proc/self/maps. glibc 2 and uClibc have the getline()
+     function.
+     Cygwin >= 1.5 has /proc/self/maps and the getline() function too.
+     But it is costly: ca. 0.3 ms on Linux, 3 ms on Cygwin 1.5, and 5 ms on
+     Cygwin 1.7.  */
   FILE *fp;
 
   /* Open the current process' maps file.  It describes one VMA per line.  */
@@ -387,7 +390,7 @@ find_shared_library_fullname ()
 #endif
 }
 
-#endif /* (WIN32 or Cygwin) / (Unix except Cygwin) */
+#endif /* WIN32 / Unix */
 
 /* Return the full pathname of the current shared library.
    Return NULL if unknown.
@@ -395,7 +398,7 @@ find_shared_library_fullname ()
 static char *
 get_shared_library_fullname ()
 {
-#if !(defined _WIN32 || defined __WIN32__ || defined __CYGWIN__)
+#if !((defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__)
   static bool tried_find_shared_library_fullname;
   if (!tried_find_shared_library_fullname)
     {
@@ -415,7 +418,7 @@ get_shared_library_fullname ()
 const char *
 relocate (const char *pathname)
 {
-#if defined PIC && defined INSTALLDIR
+#if defined PIC && defined INSTALLDIR && ENABLE_COSTLY_RELOCATABLE
   static int initialized;
 
   /* Initialization code for a shared library.  */
--- origsrc/gettext-0.18.1.1/gettext-tools/gnulib-lib/progreloc.c	2010-05-24 04:42:46.000000000 -0500
+++ src/gettext-0.18.1.1/gettext-tools/gnulib-lib/progreloc.c	2011-10-31 18:40:26.620853680 -0500
@@ -16,6 +16,7 @@
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 
+#define _GL_USE_STDLIB_ALLOC 1
 #include <config.h>
 
 /* Specification.  */
@@ -34,11 +35,11 @@
 # include <mach-o/dyld.h>
 #endif
 
-#if defined _WIN32 || defined __WIN32__
+#if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__
 # define WIN32_NATIVE
 #endif
 
-#if defined WIN32_NATIVE || defined __CYGWIN__
+#ifdef WIN32_NATIVE
 # define WIN32_LEAN_AND_MEAN
 # include <windows.h>
 #endif
@@ -59,6 +60,10 @@
 # include "xalloc.h"
 #endif
 
+#ifndef O_EXEC
+# define O_EXEC O_RDONLY /* This is often close enough in older systems.  */
+#endif
+
 /* Declare canonicalize_file_name.
    The <stdlib.h> included above may be the system's one, not the gnulib
    one.  */
@@ -68,8 +73,8 @@ extern char * canonicalize_file_name (co
    ISSLASH(C)           tests whether C is a directory separator character.
    IS_PATH_WITH_DIR(P)  tests whether P contains a directory specification.
  */
-#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__
-  /* Win32, Cygwin, OS/2, DOS */
+#if ((defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__) || defined __EMX__ || defined __DJGPP__
+  /* Win32, OS/2, DOS */
 # define ISSLASH(C) ((C) == '/' || (C) == '\\')
 # define HAS_DEVICE(P) \
     ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \
@@ -89,12 +94,15 @@ extern char * canonicalize_file_name (co
 #undef open
 #undef close
 
+/* Use the system functions, not the gnulib overrides in this file.  */
+#undef sprintf
+
 #undef set_program_name
 
 
 #if ENABLE_RELOCATABLE
 
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
 /* File descriptor of the executable.
    (Only used to verify that we find the correct executable.)  */
 static int executable_fd = -1;
@@ -104,12 +112,13 @@ static int executable_fd = -1;
 static bool
 maybe_executable (const char *filename)
 {
-  /* Woe32 lacks the access() function, but Cygwin doesn't.  */
-#if !(defined WIN32_NATIVE && !defined __CYGWIN__)
+  /* Woe32 lacks the access() function.  */
+#if !defined WIN32_NATIVE
   if (access (filename, X_OK) < 0)
     return false;
+#endif
 
-#ifdef __linux__
+#if defined __linux__ || defined __CYGWIN__
   if (executable_fd >= 0)
     {
       /* If we already have an executable_fd, check that filename points to
@@ -128,7 +137,6 @@ maybe_executable (const char *filename)
         }
     }
 #endif
-#endif
 
   return true;
 }
@@ -140,7 +148,12 @@ maybe_executable (const char *filename)
 static char *
 find_executable (const char *argv0)
 {
-#if defined WIN32_NATIVE || defined __CYGWIN__
+#if defined WIN32_NATIVE
+  /* Native Win32 only.
+     On Cygwin, it is better to use the Cygwin provided /proc interface, than
+     to use native Win32 API and cygwin_conv_to_posix_path, because it supports
+     longer file names
+     (see <http://cygwin.com/ml/cygwin/2011-01/msg00410.html>).  */
   char location[MAX_PATH];
   int length = GetModuleFileName (NULL, location, sizeof (location));
   if (length < 0)
@@ -148,32 +161,9 @@ find_executable (const char *argv0)
   if (!IS_PATH_WITH_DIR (location))
     /* Shouldn't happen.  */
     return NULL;
-  {
-#if defined __CYGWIN__
-    /* cygwin-1.5.13 (2005-03-01) or newer would also allow a Linux-like
-       implementation: readlink of "/proc/self/exe".  But using the
-       result of the Win32 system call is simpler and is consistent with the
-       code in relocatable.c.  */
-    /* On Cygwin, we need to convert paths coming from Win32 system calls
-       to the Unix-like slashified notation.  */
-    static char location_as_posix_path[2 * MAX_PATH];
-    /* There's no error return defined for cygwin_conv_to_posix_path.
-       See cygwin-api/func-cygwin-conv-to-posix-path.html.
-       Does it overflow the buffer of expected size MAX_PATH or does it
-       truncate the path?  I don't know.  Let's catch both.  */
-    cygwin_conv_to_posix_path (location, location_as_posix_path);
-    location_as_posix_path[MAX_PATH - 1] = '\0';
-    if (strlen (location_as_posix_path) >= MAX_PATH - 1)
-      /* A sign of buffer overflow or path truncation.  */
-      return NULL;
-    /* Call canonicalize_file_name, because Cygwin supports symbolic links.  */
-    return canonicalize_file_name (location_as_posix_path);
-#else
-    return xstrdup (location);
-#endif
-  }
-#else /* Unix && !Cygwin */
-#ifdef __linux__
+  return xstrdup (location);
+#else /* Unix */
+# ifdef __linux__
   /* The executable is accessible as /proc/<pid>/exe.  In newer Linux
      versions, also as /proc/self/exe.  Linux >= 2.1 provides a symlink
      to the true pathname; older Linux versions give only device and ino,
@@ -185,7 +175,7 @@ find_executable (const char *argv0)
     if (link != NULL && link[0] != '[')
       return link;
     if (executable_fd < 0)
-      executable_fd = open ("/proc/self/exe", O_RDONLY, 0);
+      executable_fd = open ("/proc/self/exe", O_EXEC, 0);
 
     {
       char buf[6+10+5];
@@ -194,11 +184,24 @@ find_executable (const char *argv0)
       if (link != NULL && link[0] != '[')
         return link;
       if (executable_fd < 0)
-        executable_fd = open (buf, O_RDONLY, 0);
+        executable_fd = open (buf, O_EXEC, 0);
     }
   }
-#endif
-#if HAVE_MACH_O_DYLD_H && HAVE__NSGETEXECUTABLEPATH
+# endif
+# ifdef __CYGWIN__
+  /* The executable is accessible as /proc/<pid>/exe, at least in
+     Cygwin >= 1.5.  */
+  {
+    char *link;
+
+    link = xreadlink ("/proc/self/exe");
+    if (link != NULL)
+      return link;
+    if (executable_fd < 0)
+      executable_fd = open ("/proc/self/exe", O_EXEC, 0);
+  }
+# endif
+# if HAVE_MACH_O_DYLD_H && HAVE__NSGETEXECUTABLEPATH
   /* On MacOS X 10.2 or newer, the function
        int _NSGetExecutablePath (char *buf, uint32_t *bufsize);
      can be used to retrieve the executable's full path.  */
@@ -207,7 +210,7 @@ find_executable (const char *argv0)
   if (_NSGetExecutablePath (location, &length) == 0
       && location[0] == '/')
     return canonicalize_file_name (location);
-#endif
+# endif
   /* Guess the executable's full path.  We assume the executable has been
      called via execlp() or execvp() with properly set up argv[0].  The
      login(1) convention to add a '-' prefix to argv[0] is not supported.  */
@@ -248,10 +251,10 @@ find_executable (const char *argv0)
                 /* We have a path item at p, of length p_len.
                    Now concatenate the path item and argv0.  */
                 concat_name = (char *) xmalloc (p_len + strlen (argv0) + 2);
-#ifdef NO_XMALLOC
+# ifdef NO_XMALLOC
                 if (concat_name == NULL)
                   return NULL;
-#endif
+# endif
                 if (p_len == 0)
                   /* An empty PATH element designates the current directory.  */
                   strcpy (concat_name, argv0);
--- origsrc/gettext-0.18.1.1/gettext-tools/gnulib-lib/relocatable.c	2010-05-24 04:42:46.000000000 -0500
+++ src/gettext-0.18.1.1/gettext-tools/gnulib-lib/relocatable.c	2011-10-31 18:40:29.868853403 -0500
@@ -25,6 +23,7 @@
 # define _GNU_SOURCE 1
 #endif
 
+#define _GL_USE_STDLIB_ALLOC 1
 #include <config.h>
 
 /* Specification.  */
@@ -43,7 +42,7 @@
 # include "xalloc.h"
 #endif
 
-#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__
+#if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__
 # define WIN32_LEAN_AND_MEAN
 # include <windows.h>
 #endif
@@ -70,8 +69,8 @@
    ISSLASH(C)           tests whether C is a directory separator character.
    IS_PATH_WITH_DIR(P)  tests whether P contains a directory specification.
  */
-#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__
-  /* Win32, Cygwin, OS/2, DOS */
+#if ((defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__) || defined __EMX__ || defined __DJGPP__
+  /* Win32, OS/2, DOS */
 # define ISSLASH(C) ((C) == '/' || (C) == '\\')
 # define HAS_DEVICE(P) \
     ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \
@@ -86,6 +85,19 @@
 # define FILE_SYSTEM_PREFIX_LEN(P) 0
 #endif
 
+/* Whether to enable the more costly support for relocatable libraries.
+   It allows libraries to be have been installed with a different original
+   prefix than the program.  But it is quite costly, especially on Cygwin
+   platforms, see below.  Therefore we enable it by default only on native
+   Win32 platforms.  */
+#ifndef ENABLE_COSTLY_RELOCATABLE
+# if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__
+#  define ENABLE_COSTLY_RELOCATABLE 1
+# else
+#  define ENABLE_COSTLY_RELOCATABLE 0
+# endif
+#endif
+
 /* Original installation prefix.  */
 static char *orig_prefix;
 static size_t orig_prefix_len;
@@ -155,7 +167,7 @@ set_relocation_prefix (const char *orig_
 #endif
 }
 
-#if !defined IN_LIBRARY || (defined PIC && defined INSTALLDIR)
+#if !defined IN_LIBRARY || (defined PIC && defined INSTALLDIR && ENABLE_COSTLY_RELOCATABLE)
 
 /* Convenience function:
    Computes the current installation prefix, based on the original
@@ -285,12 +297,17 @@ compute_curr_prefix (const char *orig_in
 
 #endif /* !IN_LIBRARY || PIC */
 
-#if defined PIC && defined INSTALLDIR
+#if defined PIC && defined INSTALLDIR && ENABLE_COSTLY_RELOCATABLE
 
 /* Full pathname of shared library, or NULL.  */
 static char *shared_library_fullname;
 
-#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__
+#if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__
+/* Native Win32 only.
+   On Cygwin, it is better to use the Cygwin provided /proc interface, than
+   to use native Win32 API and cygwin_conv_to_posix_path, because it supports
+   longer file names
+   (see <http://cygwin.com/ml/cygwin/2011-01/msg00410.html>).  */
 
 /* Determine the full pathname of the shared library when it is loaded.  */
 
@@ -312,37 +329,23 @@ DllMain (HINSTANCE module_handle, DWORD 
         /* Shouldn't happen.  */
         return FALSE;
 
-      {
-#if defined __CYGWIN__
-        /* On Cygwin, we need to convert paths coming from Win32 system calls
-           to the Unix-like slashified notation.  */
-        static char location_as_posix_path[2 * MAX_PATH];
-        /* There's no error return defined for cygwin_conv_to_posix_path.
-           See cygwin-api/func-cygwin-conv-to-posix-path.html.
-           Does it overflow the buffer of expected size MAX_PATH or does it
-           truncate the path?  I don't know.  Let's catch both.  */
-        cygwin_conv_to_posix_path (location, location_as_posix_path);
-        location_as_posix_path[MAX_PATH - 1] = '\0';
-        if (strlen (location_as_posix_path) >= MAX_PATH - 1)
-          /* A sign of buffer overflow or path truncation.  */
-          return FALSE;
-        shared_library_fullname = strdup (location_as_posix_path);
-#else
-        shared_library_fullname = strdup (location);
-#endif
-      }
+      shared_library_fullname = strdup (location);
     }
 
   return TRUE;
 }
 
-#else /* Unix except Cygwin */
+#else /* Unix */
 
 static void
 find_shared_library_fullname ()
 {
-#if defined __linux__ && __GLIBC__ >= 2
-  /* Linux has /proc/self/maps. glibc 2 has the getline() function.  */
+#if (defined __linux__ && (__GLIBC__ >= 2 || defined __UCLIBC__)) || defined __CYGWIN__
+  /* Linux has /proc/self/maps. glibc 2 and uClibc have the getline()
+     function.
+     Cygwin >= 1.5 has /proc/self/maps and the getline() function too.
+     But it is costly: ca. 0.3 ms on Linux, 3 ms on Cygwin 1.5, and 5 ms on
+     Cygwin 1.7.  */
   FILE *fp;
 
   /* Open the current process' maps file.  It describes one VMA per line.  */
@@ -387,7 +390,7 @@ find_shared_library_fullname ()
 #endif
 }
 
-#endif /* (WIN32 or Cygwin) / (Unix except Cygwin) */
+#endif /* WIN32 / Unix */
 
 /* Return the full pathname of the current shared library.
    Return NULL if unknown.
@@ -395,7 +398,7 @@ find_shared_library_fullname ()
 static char *
 get_shared_library_fullname ()
 {
-#if !(defined _WIN32 || defined __WIN32__ || defined __CYGWIN__)
+#if !((defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__)
   static bool tried_find_shared_library_fullname;
   if (!tried_find_shared_library_fullname)
     {
@@ -415,7 +418,7 @@ get_shared_library_fullname ()
 const char *
 relocate (const char *pathname)
 {
-#if defined PIC && defined INSTALLDIR
+#if defined PIC && defined INSTALLDIR && ENABLE_COSTLY_RELOCATABLE
   static int initialized;
 
   /* Initialization code for a shared library.  */
--- origsrc/gettext-0.18.1.1/gettext-tools/libgettextpo/relocatable.c	2010-02-16 15:33:15.000000000 -0600
+++ src/gettext-0.18.1.1/gettext-tools/libgettextpo/relocatable.c	2011-10-31 18:40:29.868853403 -0500
@@ -25,6 +23,7 @@
 # define _GNU_SOURCE 1
 #endif
 
+#define _GL_USE_STDLIB_ALLOC 1
 #include <config.h>
 
 /* Specification.  */
@@ -43,7 +42,7 @@
 # include "xalloc.h"
 #endif
 
-#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__
+#if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__
 # define WIN32_LEAN_AND_MEAN
 # include <windows.h>
 #endif
@@ -70,8 +69,8 @@
    ISSLASH(C)           tests whether C is a directory separator character.
    IS_PATH_WITH_DIR(P)  tests whether P contains a directory specification.
  */
-#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__
-  /* Win32, Cygwin, OS/2, DOS */
+#if ((defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__) || defined __EMX__ || defined __DJGPP__
+  /* Win32, OS/2, DOS */
 # define ISSLASH(C) ((C) == '/' || (C) == '\\')
 # define HAS_DEVICE(P) \
     ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \
@@ -86,6 +85,19 @@
 # define FILE_SYSTEM_PREFIX_LEN(P) 0
 #endif
 
+/* Whether to enable the more costly support for relocatable libraries.
+   It allows libraries to be have been installed with a different original
+   prefix than the program.  But it is quite costly, especially on Cygwin
+   platforms, see below.  Therefore we enable it by default only on native
+   Win32 platforms.  */
+#ifndef ENABLE_COSTLY_RELOCATABLE
+# if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__
+#  define ENABLE_COSTLY_RELOCATABLE 1
+# else
+#  define ENABLE_COSTLY_RELOCATABLE 0
+# endif
+#endif
+
 /* Original installation prefix.  */
 static char *orig_prefix;
 static size_t orig_prefix_len;
@@ -155,7 +167,7 @@ set_relocation_prefix (const char *orig_
 #endif
 }
 
-#if !defined IN_LIBRARY || (defined PIC && defined INSTALLDIR)
+#if !defined IN_LIBRARY || (defined PIC && defined INSTALLDIR && ENABLE_COSTLY_RELOCATABLE)
 
 /* Convenience function:
    Computes the current installation prefix, based on the original
@@ -285,12 +297,17 @@ compute_curr_prefix (const char *orig_in
 
 #endif /* !IN_LIBRARY || PIC */
 
-#if defined PIC && defined INSTALLDIR
+#if defined PIC && defined INSTALLDIR && ENABLE_COSTLY_RELOCATABLE
 
 /* Full pathname of shared library, or NULL.  */
 static char *shared_library_fullname;
 
-#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__
+#if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__
+/* Native Win32 only.
+   On Cygwin, it is better to use the Cygwin provided /proc interface, than
+   to use native Win32 API and cygwin_conv_to_posix_path, because it supports
+   longer file names
+   (see <http://cygwin.com/ml/cygwin/2011-01/msg00410.html>).  */
 
 /* Determine the full pathname of the shared library when it is loaded.  */
 
@@ -312,37 +329,23 @@ DllMain (HINSTANCE module_handle, DWORD 
         /* Shouldn't happen.  */
         return FALSE;
 
-      {
-#if defined __CYGWIN__
-        /* On Cygwin, we need to convert paths coming from Win32 system calls
-           to the Unix-like slashified notation.  */
-        static char location_as_posix_path[2 * MAX_PATH];
-        /* There's no error return defined for cygwin_conv_to_posix_path.
-           See cygwin-api/func-cygwin-conv-to-posix-path.html.
-           Does it overflow the buffer of expected size MAX_PATH or does it
-           truncate the path?  I don't know.  Let's catch both.  */
-        cygwin_conv_to_posix_path (location, location_as_posix_path);
-        location_as_posix_path[MAX_PATH - 1] = '\0';
-        if (strlen (location_as_posix_path) >= MAX_PATH - 1)
-          /* A sign of buffer overflow or path truncation.  */
-          return FALSE;
-        shared_library_fullname = strdup (location_as_posix_path);
-#else
-        shared_library_fullname = strdup (location);
-#endif
-      }
+      shared_library_fullname = strdup (location);
     }
 
   return TRUE;
 }
 
-#else /* Unix except Cygwin */
+#else /* Unix */
 
 static void
 find_shared_library_fullname ()
 {
-#if defined __linux__ && __GLIBC__ >= 2
-  /* Linux has /proc/self/maps. glibc 2 has the getline() function.  */
+#if (defined __linux__ && (__GLIBC__ >= 2 || defined __UCLIBC__)) || defined __CYGWIN__
+  /* Linux has /proc/self/maps. glibc 2 and uClibc have the getline()
+     function.
+     Cygwin >= 1.5 has /proc/self/maps and the getline() function too.
+     But it is costly: ca. 0.3 ms on Linux, 3 ms on Cygwin 1.5, and 5 ms on
+     Cygwin 1.7.  */
   FILE *fp;
 
   /* Open the current process' maps file.  It describes one VMA per line.  */
@@ -387,7 +390,7 @@ find_shared_library_fullname ()
 #endif
 }
 
-#endif /* (WIN32 or Cygwin) / (Unix except Cygwin) */
+#endif /* WIN32 / Unix */
 
 /* Return the full pathname of the current shared library.
    Return NULL if unknown.
@@ -395,7 +398,7 @@ find_shared_library_fullname ()
 static char *
 get_shared_library_fullname ()
 {
-#if !(defined _WIN32 || defined __WIN32__ || defined __CYGWIN__)
+#if !((defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__)
   static bool tried_find_shared_library_fullname;
   if (!tried_find_shared_library_fullname)
     {
@@ -415,7 +418,7 @@ get_shared_library_fullname ()
 const char *
 relocate (const char *pathname)
 {
-#if defined PIC && defined INSTALLDIR
+#if defined PIC && defined INSTALLDIR && ENABLE_COSTLY_RELOCATABLE
   static int initialized;
 
   /* Initialization code for a shared library.  */
